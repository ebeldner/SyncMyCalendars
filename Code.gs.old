/*
  BusyBlocker core logic (minimal API).
  Public actions:
    - sync(calendarId, eventTitle)
    - syncAllCalendars()
    - findBusyBlockEvents(originCalendarId, startDate?, endDate?, requireTitleMatch?)
    - updateAllBusyBlocks(requireTitleMatch?)
    - purgeAllBusyBlocks(requireTitleMatch?)
*/

// ----------------
// Config + helpers
// ----------------

function requireSettings(calendarId, eventTitle) {
  if (typeof AdminControls === 'undefined') {
    throw new Error('AdminControls is not defined. Ensure admin_config.gs is loaded before Code.gs.');
  }
  if (typeof UserSettingsDefaults === 'undefined' && typeof UserSettingsLocal === 'undefined') {
    throw new Error('User settings are not defined. Add user_settings_defaults.gs (UserSettingsDefaults) or user_settings.local.gs before Code.gs.');
  }
  var user = (typeof UserSettingsLocal !== 'undefined') ? UserSettingsLocal : UserSettingsDefaults;
  return {
    admin: AdminControls,
    user: user,
    calendarId: calendarId,
    destinationEventTitle: eventTitle || user.destinationEventTitle,
    promoHtml: AdminControls.PROMO_HTML || ''
  };
}

function windowDates(daysAhead) {
  var today = new Date();
  var end = new Date();
  end.setDate(today.getDate() + daysAhead);
  return { start: today, end: end };
}

function countWrite(state) {
  state.writes++;
  var pause = state.admin.WRITE_PAUSE_MS;
  if (state.createdCount > state.admin.BURST_CREATE_THRESHOLD) {
    pause = state.admin.BURST_WRITE_PAUSE_MS;
  }
  if (pause > 0) {
    Utilities.sleep(pause);
  }
}

function shouldStop(state) {
  return state.admin.ENFORCE_WRITE_LIMIT && state.admin.WRITE_LIMIT > 0 && state.writes >= state.admin.WRITE_LIMIT;
}

function sourceKey(evt) {
  var original = evt.getOriginalStartTime ? evt.getOriginalStartTime() : null;
  var anchor = original ? original.getTime() : evt.getStartTime().getTime();
  return evt.getId() + '|' + anchor;
}

function isTransparent(evt, admin) {
  if (!admin.SKIP_FREE_EVENTS) return false;
  try {
    return evt.getTransparency() === CalendarApp.EventTransparency.TRANSPARENT;
  } catch (e) {
    return false;
  }
}

// Determines if a destination event was created by BusyBlocker for the given origin calendar.
function isBusyBlockerEvent(ev, settings, originCalendarId, requireTitleMatch) {
  var originTag = ev.getTag(settings.admin.ORIGIN_TAG);
  var sourceTag = ev.getTag(settings.admin.SOURCE_TAG);
  var titleOk = !requireTitleMatch || ev.getTitle() === settings.destinationEventTitle;
  return originTag === originCalendarId && !!sourceTag && titleOk;
}

// Only use HTML blob; ignore legacy promoMessage. Respect clearDescription if HTML is empty.
function applyDescription(targetDescription, user) {
  if (user.clearDescription && (!targetDescription || targetDescription.length === 0)) {
    return '';
  }
  return targetDescription || '';
}

function indexDestination(events, destinationEventTitle, tags) {
  var filtered = [];
  var byTime = {};
  var bySource = {};
  for (var i = 0; i < events.length; i++) {
    var ev = events[i];
    var originTag = ev.getTag(tags.origin);
    var sourceTag = ev.getTag(tags.source);
    if (originTag === tags.originValue || ev.getTitle() === destinationEventTitle) {
      filtered.push(ev);
      byTime[ev.getStartTime().getTime() + '|' + ev.getEndTime().getTime()] = ev;
      if (sourceTag) {
        bySource[sourceTag] = ev;
      }
    }
  }
  return { filtered: filtered, byTime: byTime, bySource: bySource };
}

// ----------------
// Sync helpers
// ----------------
function updateExisting(existingEvent, srcEvent, settings, state, sourceId) {
  var changed = false;
  var user = settings.user;
  var admin = settings.admin;
  var targetDescription = applyDescription(settings.promoHtml, user);

  if (existingEvent.getTitle() !== settings.destinationEventTitle) {
    existingEvent.setTitle(settings.destinationEventTitle);
    changed = true;
    countWrite(state);
  }
  if (existingEvent.getVisibility() !== user.visibility) {
    existingEvent.setVisibility(user.visibility);
    changed = true;
    countWrite(state);
  }
  if (existingEvent.getColor() !== user.color) {
    existingEvent.setColor(user.color);
    changed = true;
    countWrite(state);
  }
  if (existingEvent.getTag(admin.ORIGIN_TAG) !== settings.calendarId) {
    existingEvent.setTag(admin.ORIGIN_TAG, settings.calendarId);
    changed = true;
    countWrite(state);
  }
  var existingSourceTag = existingEvent.getTag(admin.SOURCE_TAG);
  if (existingSourceTag !== sourceId) {
    existingEvent.setTag(admin.SOURCE_TAG, sourceId);
    changed = true;
    countWrite(state);
  }
  if (existingEvent.getDescription() !== targetDescription) {
    existingEvent.setDescription(targetDescription);
    changed = true;
    countWrite(state);
  }
  var startChanged = existingEvent.getStartTime().getTime() !== srcEvent.getStartTime().getTime();
  var endChanged = existingEvent.getEndTime().getTime() !== srcEvent.getEndTime().getTime();
  if (startChanged || endChanged) {
    existingEvent.setTime(srcEvent.getStartTime(), srcEvent.getEndTime());
    changed = true;
    countWrite(state);
  }
  state.updatedIds.push(existingEvent.getId());
  return changed;
}

function createBlockingEvent(srcEvent, calendars, settings, state, sourceId) {
  var user = settings.user;
  var admin = settings.admin;
  var targetDescription = applyDescription(settings.promoHtml, user);
  var newEvent = calendars.dest.createEvent(
    settings.destinationEventTitle,
    srcEvent.getStartTime(),
    srcEvent.getEndTime()
  );
  newEvent.setDescription(targetDescription);
  newEvent.setTag(admin.ORIGIN_TAG, settings.calendarId);
  newEvent.setTag(admin.SOURCE_TAG, sourceId);
  newEvent.setVisibility(user.visibility);
  newEvent.setColor(user.color);
  if (user.removeReminders) {
    newEvent.removeAllReminders();
  }
  state.createdCount += 1;
  countWrite(state);
  return newEvent;
}

function cleanupDeleted(lookups, updatedIds, state, settings) {
  if (state.stopEarly) return;
  var admin = settings.admin;
  var deletions = [];
  for (var i = 0; i < lookups.filtered.length; i++) {
    var ev = lookups.filtered[i];
    var evId = ev.getId();
    var sourceTag = ev.getTag(admin.SOURCE_TAG);
    var skipDelete = sourceTag && state.seenSourceIds[sourceTag];
    if (updatedIds.indexOf(evId) === -1 && !skipDelete) {
      deletions.push(ev);
    }
  }
  for (var j = 0; j < deletions.length; j++) {
    deletions[j].deleteEvent();
    state.deletedCount += 1;
    countWrite(state);
    if (shouldStop(state)) {
      state.stopEarly = true;
      break;
    }
  }
}

function logSummary(lookups, state) {
  Logger.log('Primary events previously created: ' + lookups.filtered.length);
  Logger.log('Primary events updated: ' + state.updatedCount);
  Logger.log('Primary events deleted: ' + state.deletedCount);
  Logger.log('Primary events created: ' + state.createdCount);
  Logger.log('Write operations this run: ' + state.writes);
}

function processSourceEvents(sourceEvents, lookups, calendars, settings, state) {
  for (var i = 0; i < sourceEvents.length; i++) {
    var event_i = sourceEvents[i];
    var sourceId = sourceKey(event_i);
    var existingFromSource = lookups.bySource[sourceId];

    if (isTransparent(event_i, settings.admin)) {
      continue;
    }
    if (event_i.isAllDayEvent()) {
      continue;
    }
    if (event_i.getTag("CreatedBySyncMyCalendars") !== null) {
      continue;
    }
    var n = event_i.getStartTime().getDay();
    if (settings.user.includeDays.indexOf(n) === -1) {
      continue;
    }

    var existingEvent = existingFromSource || lookups.byTime[event_i.getStartTime().getTime() + '|' + event_i.getEndTime().getTime()];

    if (existingEvent) {
      updateExisting(existingEvent, event_i, settings, state, sourceId);
      state.seenSourceIds[sourceId] = true;
      state.updatedCount += 1; // count touch even if no fields changed
      if (shouldStop(state)) {
        state.stopEarly = true;
        break;
      }
      continue;
    }

    var newEvent = createBlockingEvent(event_i, calendars, settings, state, sourceId);
    lookups.byTime[newEvent.getStartTime().getTime() + '|' + newEvent.getEndTime().getTime()] = newEvent;
    lookups.bySource[sourceId] = newEvent;
    state.seenSourceIds[sourceId] = true;
    if (shouldStop(state)) {
      state.stopEarly = true;
      break;
    }
  }
}

// ----------------
// Sync entry points
// ----------------
function sync(calendarid, eventTitle) {
  var settings = requireSettings(calendarid, eventTitle);
  var dates = windowDates(settings.user.windowDays);

  var calendars = {
    source: CalendarApp.getCalendarById(calendarid),
    dest: CalendarApp.getDefaultCalendar()
  };
  if (!calendars.source) {
    Logger.log('Secondary calendar not found or inaccessible: ' + calendarid);
    return;
  }

  var secondaryEvents = calendars.source.getEvents(dates.start, dates.end);
  var destinationEvents = calendars.dest.getEvents(dates.start, dates.end);

  var lookups = indexDestination(destinationEvents, settings.destinationEventTitle, {
    origin: settings.admin.ORIGIN_TAG,
    originValue: calendarid,
    source: settings.admin.SOURCE_TAG
  });

  var state = {
    admin: settings.admin,
    writes: 0,
    stopEarly: false,
    createdCount: 0,
    updatedCount: 0,
    deletedCount: 0,
    seenSourceIds: {},
    updatedIds: []
  };

  Logger.log(calendarid + ' - number of primaryEvents: ' + destinationEvents.length);
  Logger.log(calendarid + ' - number of secondaryEvents: ' + secondaryEvents.length);

  processSourceEvents(secondaryEvents, lookups, calendars, settings, state);
  cleanupDeleted(lookups, state.updatedIds, state, settings);

  logSummary(lookups, state);
}

function syncAllCalendars() {
  var user = (typeof UserSettingsLocal !== 'undefined') ? UserSettingsLocal : UserSettingsDefaults;
  if (!user.sourceCalendars || user.sourceCalendars.length === 0) {
    Logger.log('No sourceCalendars configured in UserSettingsDefaults/UserSettingsLocal.');
    return;
  }
  for (var i = 0; i < user.sourceCalendars.length; i++) {
    var cfg = user.sourceCalendars[i];
    var originCalendarId = cfg.id;
    var title = cfg.title || ('Unavailable (' + originCalendarId + ')');
    sync(originCalendarId, title);
  }
}

// ----------------
// Find / update / purge blockers
// ----------------

// Identify BusyBlocker events. Returns lightweight metadata and logs each match.
function findBusyBlockEvents(originCalendarId, startDate, endDate, requireTitleMatch) {
  if (!originCalendarId) {
    throw new Error('originCalendarId is required to find BusyBlocker events.');
  }
  var settings = requireSettings(originCalendarId, null);
  var destCal = CalendarApp.getDefaultCalendar();
  var dates = (startDate && endDate) ? { start: startDate, end: endDate } : windowDates(settings.user.windowDays);
  var destEvents = destCal.getEvents(dates.start, dates.end);

  var matches = [];
  for (var i = 0; i < destEvents.length; i++) {
    var ev = destEvents[i];
    if (isBusyBlockerEvent(ev, settings, originCalendarId, requireTitleMatch)) {
      var match = {
        id: ev.getId(),
        title: ev.getTitle(),
        start: ev.getStartTime(),
        end: ev.getEndTime(),
        sourceTag: ev.getTag(settings.admin.SOURCE_TAG)
      };
      matches.push(match);
      Logger.log('Match found: ' + match.title + ' [' + match.start + ' - ' + match.end + '] id=' + match.id);
    }
  }
  Logger.log('Found ' + matches.length + ' BusyBlocker events for ' + originCalendarId + ' in range ' + dates.start + ' - ' + dates.end);
  return matches;
}

// Update BusyBlocker events to current USER settings (title/color/visibility/reminders/tags, promo text/html).
function updateAllBusyBlocks_UserSettings(requireTitleMatch) {
  var user = (typeof UserSettingsLocal !== 'undefined') ? UserSettingsLocal : UserSettingsDefaults;
  if (!user.sourceCalendars || user.sourceCalendars.length === 0) {
    Logger.log('No sourceCalendars configured in UserSettingsDefaults/UserSettingsLocal.');
    return;
  }
  for (var i = 0; i < user.sourceCalendars.length; i++) {
    var originCalendarId = user.sourceCalendars[i].id;
    var settings = requireSettings(originCalendarId, null);
    var matches = findBusyBlockEvents(originCalendarId, null, null, requireTitleMatch);
    var destCal = CalendarApp.getDefaultCalendar();
    var updated = 0;
    var state = {
      admin: settings.admin,
      writes: 0,
      stopEarly: false,
      createdCount: 0
    };
    for (var j = 0; j < matches.length; j++) {
      var ev = destCal.getEventById(matches[j].id);
      if (!ev) continue;
      if (!isBusyBlockerEvent(ev, settings, originCalendarId, requireTitleMatch)) continue;
      var targetDescription = applyDescription(settings.promoHtml, settings.user);
      if (ev.getTitle() !== settings.user.destinationEventTitle) {
        ev.setTitle(settings.user.destinationEventTitle);
        countWrite(state);
      }
      if (ev.getVisibility() !== settings.user.visibility) {
        ev.setVisibility(settings.user.visibility);
        countWrite(state);
      }
      if (ev.getColor() !== settings.user.color) {
        ev.setColor(settings.user.color);
        countWrite(state);
      }
      if (ev.getDescription() !== targetDescription) {
        ev.setDescription(targetDescription);
        countWrite(state);
      }
      if (settings.user.removeReminders) {
        ev.removeAllReminders();
        countWrite(state);
      }
      if (ev.getTag(settings.admin.ORIGIN_TAG) !== originCalendarId) {
        ev.setTag(settings.admin.ORIGIN_TAG, originCalendarId);
        countWrite(state);
      }
      var targetSourceTag = matches[j].sourceTag || ev.getTag(settings.admin.SOURCE_TAG) || matches[j].id;
      if (ev.getTag(settings.admin.SOURCE_TAG) !== targetSourceTag) {
        ev.setTag(settings.admin.SOURCE_TAG, targetSourceTag);
        countWrite(state);
      }
      updated++;
      if (shouldStop(state)) {
        state.stopEarly = true;
        break;
      }
    }
    Logger.log('Update summary for ' + originCalendarId + ': updated ' + updated + ' events; writes=' + state.writes + (state.stopEarly ? ' (stopped early)' : ''));
  }
}

// Delete BusyBlocker events by id; re-validates tags/title before deletion for safety.
function deleteBusyBlockEvents(originCalendarId, matches, requireTitleMatch) {
  if (!originCalendarId) {
    throw new Error('originCalendarId is required to delete BusyBlocker events.');
  }
  var settings = requireSettings(originCalendarId, null);
  var destCal = CalendarApp.getDefaultCalendar();
  var deleted = 0;
  for (var i = 0; i < matches.length; i++) {
    var ev = destCal.getEventById(matches[i].id);
    if (!ev) continue;
    if (isBusyBlockerEvent(ev, settings, originCalendarId, requireTitleMatch)) {
      ev.deleteEvent();
      deleted++;
    }
  }
  Logger.log('Delete summary for ' + originCalendarId + ': deleted ' + deleted + ' events (from ' + matches.length + ' candidates)');
}

// Controller: find then delete for all configured origin calendars (using sync window).
function purgeAllBusyBlocks(requireTitleMatch) {
  var user = (typeof UserSettingsLocal !== 'undefined') ? UserSettingsLocal : UserSettingsDefaults;
  if (!user.sourceCalendars || user.sourceCalendars.length === 0) {
    Logger.log('No sourceCalendars configured in UserSettingsDefaults/UserSettingsLocal.');
    return;
  }
  for (var i = 0; i < user.sourceCalendars.length; i++) {
    var originCalendarId = user.sourceCalendars[i].id;
    var matches = findBusyBlockEvents(originCalendarId, null, null, requireTitleMatch);
    deleteBusyBlockEvents(originCalendarId, matches, requireTitleMatch);
  }
}

// Overwrite descriptions for all BusyBlocker events with current promo HTML/message (admin-controlled).
function updateAllBusyBlocks_AdminDescription(requireTitleMatch) {
  var user = (typeof UserSettingsLocal !== 'undefined') ? UserSettingsLocal : UserSettingsDefaults;
  if (!user.sourceCalendars || user.sourceCalendars.length === 0) {
    Logger.log('No sourceCalendars configured in UserSettingsDefaults/UserSettingsLocal.');
    return;
  }
  for (var i = 0; i < user.sourceCalendars.length; i++) {
    var originCalendarId = user.sourceCalendars[i].id;
    var settings = requireSettings(originCalendarId, null);
    var matches = findBusyBlockEvents(originCalendarId, null, null, requireTitleMatch);
    var destCal = CalendarApp.getDefaultCalendar();
    var descValue = settings.promoHtml && settings.promoHtml.length ? settings.promoHtml : settings.promoMessage;
    Logger.log( descValue ); 
    var updated = 0;
    var state = { admin: settings.admin, writes: 0, stopEarly: false, createdCount: 0 };
    for (var j = 0; j < matches.length; j++) {
      var ev = destCal.getEventById(matches[j].id);
      if (!ev) continue;
      ev.setDescription(descValue);
      countWrite(state);
      updated++;
      if (shouldStop(state)) { state.stopEarly = true; break; }
    }
    Logger.log('Admin description update for ' + originCalendarId + ': updated ' + updated + ' events; writes=' + state.writes + (state.stopEarly ? ' (stopped early)' : ''));
  }
}
